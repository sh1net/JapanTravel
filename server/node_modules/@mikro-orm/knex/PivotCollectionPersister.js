"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PivotCollectionPersister = void 0;
const core_1 = require("@mikro-orm/core");
class InsertStatement {
    keys;
    data;
    order;
    constructor(keys, data, order) {
        this.keys = keys;
        this.data = data;
        this.order = order;
    }
    getHash() {
        return JSON.stringify(this.data);
    }
    getData() {
        const data = {};
        this.keys.forEach((key, idx) => data[key] = this.data[idx]);
        return data;
    }
}
class DeleteStatement {
    keys;
    cond;
    constructor(keys, cond) {
        this.keys = keys;
        this.cond = cond;
    }
    getHash() {
        return JSON.stringify(this.cond);
    }
    getCondition() {
        const cond = {};
        this.keys.forEach((key, idx) => cond[key] = this.cond[idx]);
        return cond;
    }
}
class PivotCollectionPersister {
    meta;
    driver;
    ctx;
    schema;
    platform;
    inserts = new Map();
    deletes = new Map();
    order = 0;
    constructor(meta, driver, ctx, schema) {
        this.meta = meta;
        this.driver = driver;
        this.ctx = ctx;
        this.schema = schema;
        this.platform = this.driver.getPlatform();
    }
    enqueueUpdate(prop, insertDiff, deleteDiff, pks) {
        if (insertDiff.length) {
            this.enqueueInsert(prop, insertDiff, pks);
        }
        if (deleteDiff === true || (Array.isArray(deleteDiff) && deleteDiff.length)) {
            this.enqueueDelete(prop, deleteDiff, pks);
        }
    }
    enqueueInsert(prop, insertDiff, pks) {
        for (const fks of insertDiff) {
            const data = prop.owner ? [...fks, ...pks] : [...pks, ...fks];
            const keys = prop.owner
                ? [...prop.inverseJoinColumns, ...prop.joinColumns]
                : [...prop.joinColumns, ...prop.inverseJoinColumns];
            const statement = new InsertStatement(keys, data, this.order++);
            const hash = statement.getHash();
            if (prop.owner || !this.inserts.has(hash)) {
                this.inserts.set(hash, statement);
            }
        }
    }
    enqueueDelete(prop, deleteDiff, pks) {
        if (deleteDiff === true) {
            const statement = new DeleteStatement(prop.joinColumns, pks);
            this.deletes.set(statement.getHash(), statement);
            return;
        }
        for (const fks of deleteDiff) {
            const data = prop.owner ? [...fks, ...pks] : [...pks, ...fks];
            const keys = prop.owner
                ? [...prop.inverseJoinColumns, ...prop.joinColumns]
                : [...prop.joinColumns, ...prop.inverseJoinColumns];
            const statement = new DeleteStatement(keys, data);
            this.deletes.set(statement.getHash(), statement);
        }
    }
    async execute() {
        if (this.deletes.size > 0) {
            const knex = this.driver.createQueryBuilder(this.meta.className, this.ctx, 'write')
                .withSchema(this.schema)
                .getKnex();
            for (const item of this.deletes.values()) {
                knex.orWhere(item.getCondition());
            }
            await this.driver.execute(knex.delete());
        }
        if (this.inserts.size === 0) {
            return;
        }
        let items = [];
        for (const insert of this.inserts.values()) {
            items[insert.order] = insert.getData();
        }
        items = items.filter(i => i);
        /* istanbul ignore else */
        if (this.platform.allowsMultiInsert()) {
            await this.driver.nativeInsertMany(this.meta.className, items, {
                ctx: this.ctx,
                schema: this.schema,
                convertCustomTypes: false,
                processCollections: false,
            });
        }
        else {
            await core_1.Utils.runSerial(items, item => {
                return this.driver.createQueryBuilder(this.meta.className, this.ctx, 'write')
                    .withSchema(this.schema)
                    .insert(item)
                    .execute('run', false);
            });
        }
    }
}
exports.PivotCollectionPersister = PivotCollectionPersister;
